/* global schedule_result_temp */
/* global selected_course */
/* global course_search_table */
/* global id_to_crn_dict */
/* global linked_course_overriden */
/* global suggestion_list */
/* global course_description_table */
/* global color_dict */
/* global schedule_result */
/* global current_class_index */
/* global class_events */
/* global current_term */
class_events = [];
current_class_index = 0;
schedule_result = [];
schedule_result_temp = [];  // this is used as a cache to speed up duplication search
color_dict = {};
course_description_table = {};
course_search_table = [];
id_to_crn_dict = {};
linked_course_overriden = {};
suggestion_list = {};
selected_course = {};
current_term = "";
bh_courses = undefined;

/**
 * Proxy functions for current schedule index.
 * Note: 1. NO boundry checking 2. It will update the UI automatically
 * @param  {number} i - the index you want to dump to. 
 */
function set_current_class_index(i) {
    current_class_index = i;
    // check all the boundaries
    $("#show-left").prop("disabled", current_class_index === 0);
    $("#show-right").prop("disabled", current_class_index == schedule_result.length - 1);
    $("#paging").text((current_class_index + 1).toString() + " / " + schedule_result.length.toString());
    $("#jump-value").val(i + 1);
    handle_schedule_render();
}

/**
 * Return a random generated GUID
 */
function guidGenerator() {
    var S4 = function () {
        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    };
    return (S4() + S4() + "-" + S4());
}
/**
 * Return the class entires that contains the crn.
 * Note that it will return the full entry of the class with all the CRNs
 * @param  {array} search_items - object obtained from search.json
 * @param  {string} crn - CRN tag used to search the search_items
 */
function get_class_entry_from_crn(search_items, crn) {
    return $.grep(search_items, function (n, i) {
        return $.inArray(crn, n.crn) != -1;
    });
}
/**
 * Fastest way to count 1's in a binary number
 * @param  {number} x - number to compute
 */
function count_one(x) {
    x = (x & (0x55555555)) + ((x >> 1) & (0x55555555));
    x = (x & (0x33333333)) + ((x >> 2) & (0x33333333));
    x = (x & (0x0f0f0f0f)) + ((x >> 4) & (0x0f0f0f0f));
    x = (x & (0x00ff00ff)) + ((x >> 8) & (0x00ff00ff));
    x = (x & (0x0000ffff)) + ((x >> 16) & (0x0000ffff));
    return x;
}

function compare_score(a, b) {
    if (a.score < b.score) { return 1; }
    else if (a.score > b.score) { return -1; }
    else { return 0; }
}

function is_in_linked_list(entry, item){
    if(typeof entry === "undefined"){
        return false;
    }
    for(key in entry){
        var array = entry[key];
        for(var i = 0; i < array.length; i++){
            if(array[i] === item){
                return true;
            }
        }
    }
    return false;
}

/**
 * Returns the score of the schedule
 * Note: currently it has two cases: 1. morning classes 2. half-hour or one hour gap
 * It will deduct the score by 5 anytime an undesirable case happends 
 * @param  {array} schedule - schedule generated by scheduling functions
 */
function score_schedule(schedule) {
    // this checks the morning and evening classes

    // flatten the time table
    var times = [0, 0, 0, 0, 0];
    for (var i = 0; i < schedule.length; i++) {
        var single_class = schedule[i];
        for (var j = 0; j < single_class.t.length; j++) {
            times[j] |= single_class.t[j];
        }
    }

    var negative_score_mask = 0xFFF00003;
    var negative_score_1 = 0;
    for (var n = 0; n < times.length; n++) {
        negative_score_1 += count_one(times[n] & negative_score_mask);
    }

    // counting for dis-continuity
    var negative_score_2 = 0;
    var negative_score_2_mask_1 = 5; //(101) check if there is a half hour gap between two classes
    var negative_score_2_mask_2 = 9; // (1001) check if there is an one hour gap between two classes
    for (var k = 0; k < times.length; k++) {
        var time = times[k];
        for (var l = 0; l < 32 - 3; l++) {
            var mask_1 = negative_score_2_mask_1 << l;
            if ((time & mask_1) === mask_1) {
                negative_score_2++;
            }
        }
        for (var m = 0; m < 32 - 5; m++) {
            var mask_2 = negative_score_2_mask_2 << m;
            if ((time & mask_2) === mask_2) {
                negative_score_2++;
            }
        }
    }

    var total_negative = negative_score_1 * 2 + negative_score_2 * 2;
    // work-around of the bug
    if (total_negative > 80) {
        return 20;
    } else {
        return 100 - total_negative;
    }
}

/**
 * Return the intersection of these two arrays
 * @param  {array} array1 - array 1
 * @param  {array} array2 - array 2
 */
function get_array_overlap(array1, array2) {
    // N * M, since it's not a large list
    var result = [];
    for (var i = 0; i < array1.length; i++) {
        for (var j = 0; j < array2.length; j++) {
            if (array1[i] === array2[j]) {
                result.push([array1[i]]);
            }
        }
    }
    return result;
}

/**
 * The core parts of the scheduling algorithm. It implements dynamic programming to speed up calculations
 * @param  {array} selected_course - class entry list
 * @param  {object} courses - object obtained from courses.json
 * @param  {array} search_items - array list obtained form search.json
 */
function schedule(selected_course, courses, search_items) {
    // result the cache
    schedule_result_temp = [];
    // flatten overridden list
    var course_overriden = [];
    for (var key in linked_course_overriden) {
        course_overriden = $.merge(course_overriden, linked_course_overriden[key]);
    }
    // create a two dimensional array
    var classes = [];
    $.each(selected_course, function (ref_key, entry) {
        classes.push(entry);
        // need to check if l exists
        var entries = get_class_entry_from_crn(search_items, entry[0]);
        if (entries.length > 0 && entries[0].l) {
            $.each(entries[0].l, function (name, links) {
                var overlapped_list = get_array_overlap(links, course_overriden);
                if (overlapped_list.length > 0) {
                    for (var i = 0; i < overlapped_list.length; i++) {
                        var entry = overlapped_list[i];
                        classes.push(entry);
                    }
                } else {
                    classes.push(links);
                }
            });
        }
    });
    var result = [];
    var current_classes = [];
    var available_classes = [];
    $.each(classes, function (index, entry1) {
        var class_entry = [];
        $.each(entry1, function (index2, entry2) {
            var entry3 = courses[entry2];
            entry3["crn"] = entry2;
            class_entry.push(entry3);
        });
        available_classes.push(class_entry);
    });
    select_course(current_classes, available_classes, result);

    for (var i = 0; i < result.length; i++) {
        var entry = result[i];
        entry.score = score_schedule(entry);
    }
    result.sort(compare_score);
    schedule_result = result;
    
    // TODO: move this part to other places
    if (schedule_result.length === 0) {
        $("#schedule-row").hide("slow");
        $(".footer").show("slow");
        BootstrapDialog.alert({
            type: BootstrapDialog.TYPE_WARNING,
            title: "I'm sorry",
            message: 'There is no available schedule that fits your course selection. Maybe try a different one?'
        });
    } else {
        set_current_class_index(0);
        // set the max jump
        $("#jump-value").attr("data-max", schedule_result.length);

    }
}

/**
 * Handles all the schedule rendering. Please call this function if you want to update the UI with a new schedule
 */
function handle_schedule_render() {
    $(".footer").fadeOut(500);

    render_star(schedule_result[current_class_index].score);

    $("#schedule-row").fadeIn(1500);
    $('#calendar').fadeIn(1500).fullCalendar('render');
    render_schedule(schedule_result[current_class_index]);

}
/**
 * Display the score based on the score.
 * Note that the minimum is 15 due to a bug in the system
 * @param  {number} score - [15-100]
 */
function render_star(score) {
    var id = 1;
    for (var i = 0; i < score; i += 20) {
        $("#star-" + id.toString()).css({
            opacity: 1,
            width: score.toString() + "%"
        });
    }
}
/**
 * Render the classes produced by the scheduling algorithm
 * @param  {array} classes
 */
function render_schedule(classes) {
    // clear the old reference. Due to the implementation of fullCalendar, it's very clumsy

    $("#calendar").fullCalendar('removeEventSource', class_events);
    // marking classes
    var marked_classes = [];
    for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < classes[i].t.length; j++) {
            // use a simple state machine here
            var has_class = false;
            var duration_count = 0;
            var first_hit = 0;
            var day = classes[i].t[j];
            for (var k = 0; k < 28; k++) {
                if ((day & (1 << k)) !== 0) {
                    // has class here
                    if (!has_class) {
                        first_hit = k;
                        has_class = true;
                    }
                    duration_count += 1;
                } else {
                    if (has_class) {
                        // a class ends
                        has_class = false;
                        marked_classes.push({
                            "n": classes[i].n,
                            "i": i,
                            'crn': classes[i].crn,
                            "day": j,
                            "duration": duration_count,
                            "start": first_hit
                        });
                        duration_count = 0;
                    }
                }
            }

            // if it finishes at the ends
            if (has_class) {
                marked_classes.push({
                    "n": classes[i].n,
                    "i": i,
                    'crn': classes.crn,
                    "day": j,
                    "duration": duration_count,
                    "start": first_hit
                });
            }
        }
    }

    class_events.length = 0;

    for (var l = 0; l < marked_classes.length; l++) {
        var marked_class = marked_classes[l];
        var start_time = moment().startOf('isoweek').add(marked_class.day, "d").add(8, "h").add(marked_class.start * 30, "m");
        var class_entry = {
            "title": marked_class.n,
            "start": start_time,
            "allDay": false,
            "end": moment().startOf('isoweek').add(marked_class.day, "d").add(8, "h").add((marked_class.start + marked_class.duration) * 30 - 5, "m"),
            "crn": marked_class.crn,
            "borderColor": color_dict[marked_class.crn]
        };
        class_events.push(class_entry);
    }

    $('#calendar').fullCalendar('addEventSource', class_events);
}

/**
 * Returns a shallow copy of an array
 * @param  {array} old_array - old array to be copied
 */
function copy_array(old_array) {
    // this does shallow copy of an array
    var result = [];
    for (var i = 0; i < old_array.length; i++) {
        result.push(old_array[i]);
    }
    return result;
}

/**
 * Adding an item to an array without duplication. Use a static/global cache to change a O(n^2) algorithm to O(n)
 * @param  {array} result - the array to be added to
 * @param  {object} entry - the item to add
 */
function add_to_array_without_dup(result, entry){
    // this is a modified N * M search
    // using previous result to speed up
    var temp = "";
    for(var i = 0; i< entry.length; i++){
        temp += entry[i].crn;
    }
    for(var j = 0; j < schedule_result_temp.length; j++){
        if(schedule_result_temp[j] === temp){
            console.log("dup found");
            return;
        }
    }
    result.push(copy_array(entry));
    schedule_result_temp.push(temp);

}

/**
 * The basic uint of function in the core scheduling algorithm. It is indeed a modified dynamic programming
 * @param  {array} current_classes - the current tree-branch that's added into the algorithm
 * @param  {array} remaining_classes - the remaining classes to be added to the scheduling algorithm
 * @param  {array} result - the scheduling result. two dimensional array
 */
function select_course(current_classes, remaining_classes, result) {
    if (remaining_classes.length === 0) {
        // a valid choice
        add_to_array_without_dup(result, current_classes);
        return;
    }

    // choose the next class
    var next_class = remaining_classes[0];
    for (var i = 0; i < next_class.length; i++) {
        // choose one by one
        var choice = next_class[i];

        // check for conflict
        if (!is_new_class_conflicted(current_classes, choice)) {
            // add it to the current list
            // and remove the next class from the remaining_classes
            current_classes.push(choice);
            remaining_classes.shift();
            // call the function recursively
            select_course(current_classes, remaining_classes, result);
            // reset the state
            current_classes.pop();
            remaining_classes.unshift(next_class);
        }

    }
}


function is_single_class_conflicted(class1, class2) {
    // bitwise operation to check the time schedule conflicts
    var time1 = class1.t;
    var time2 = class2.t;
    for (var i = 0; i < 5; i++) {
        if ((time1[i] & time2[i]) !== 0) {
            return true;
        }
    }
    return false;
}

function is_new_class_conflicted(classes, new_class) {
    // used to tell whether the new claass is conflicted with the current schedule
    for (var i = 0; i < classes.length; i++) {
        if (is_single_class_conflicted(classes[i], new_class)) {
            return true;
        }
    }
    return false;
}

/**
 * Set up twitter typeahead with the given search item
 * @param  {array} search_items - array object to be displayed in the type script
 */
function setup_typeahead(search_items) {
    // need to be extra careful about setting up multiple times   
    var filted_list = $.grep(search_items, function (entry) {
        return entry.is_l !== true;
    });
    if (typeof bh_courses === "undefined"){
    bh_courses = new Bloodhound({
        datumTokenizer: Bloodhound.tokenizers.obj.whitespace('n'),
        queryTokenizer: Bloodhound.tokenizers.whitespace,
        local: filted_list
    });
    $('#search .typeahead').typeahead(null, {
        name: 'bucknell-courses',
        source: bh_courses.ttAdapter(),
        displayKey: function (e) {
            if (e.nn) {
                return "nn";
            } else {
                return "n";
            }
        },
        templates: {
            empty: [
                '<div class="empty-message">',
                'Unable to find any courses that match the query',
                '</div>'
            ].join('\n'),
            suggestion: function (e) {
                return create_description(e, search_items)
            }
        },
        limit: 100
    });
    
    handle_tt_menu();
    } else{
        bh_courses.clear();
        bh_courses.local = filted_list;
        bh_courses.initialize(true);
    }
}


/**
 * local storage helper functions. To avoide any storage loss or unsync, any operations will
 * save the result back to the local storage.
 */
function get_local_classes() {
    var str_storage = localStorage.getItem("storage");
    var storage = JSON.parse(str_storage);
    if ((typeof storage === "undefined") || (storage === null)) {
        storage = {};
    }
    return storage;
}

function is_local_classes_empty() {
    return Object.keys(get_local_classes()).length <= 0;
}

function add_local_classes(name, entry) {
    var storage = get_local_classes();
    storage[name] = entry;
    localStorage.setItem("storage", JSON.stringify(storage));
}

function remove_local_class(name) {
    var storage = get_local_classes();
    delete storage[name];
    localStorage.setItem("storage", JSON.stringify(storage));
}

// helper funcitons ends here


/**
 * Create description for twitter typeahead.
 * @param  {object} e - the twitter typeahead event object
 * @param  {array} search_items - array used to generate the twitter typeahead
 */
function create_description(e, search_items) {
    if (e.d) {
        return '<div><strong>' + e.n + ': ' + e.ti + '</strong> <br> ' + e.d + '</div>';
    } else {
        // need to pull it out from search
        // if (e.nn) {}
        var entries = get_class_entry_from_crn(search_items, e.n);
        var entry;
        for (var i = 0; i < entries.length; i++) {
            entry = entries[i];
            if (entry.d) {
                break;
            }
        }
        return '<div><strong>' + e.n + ': ' + e.nn + '</strong> <br> ' + entry.d + '</div>';
    }
}

/**
 * Create a color for the given class. For consistence reason, if the class is used before,
 * It will return the old color.
 * @param  {array} crn_list - crn list to be assigned to color
 */
function handle_color_creation(crn_list) {
    var first_crn = crn_list[0];
    var color;
    if (!(first_crn in color_dict)) {
        color = Please.make_color({
            format: 'rgb-string'
        });
        for (var i = 0; i < crn_list.length; i++) {
            var crn = crn_list[i];
            color_dict[crn] = color;
        }
    } else {
        color = color_dict[first_crn];
    }
    return color;
}

/**
 * Returns the raw html code for creating the label dropdown
 * @param  {array} crn_list - crn list for dropdown switch
 * @param  {number} id - the id used to generate the dropdown
 * @param  {any} default_value - the original class name in case the user need to go back the full options.
 * @param  {boolean} is_linked - if set true, if will label the dropdown as linked
 */
function create_label_dropdown(crn_list, id, default_value, is_linked) {
    // do a linear search
    // doing as best as I can
    var count = 0;
    var result = "";
    var temp_list = {};
    for (var i = 0; i < course_search_table.length && count < crn_list.length; i++) {
        var entry = course_search_table[i];
        if (crn_list.indexOf(entry.n) >= 0) {
            temp_list[entry.n] = entry.nn;
            count++;
        }
    }
    result += '<li ref="' + id + '" data-linked="' + (is_linked ? 'yes' : 'no') + '"><a style="color:white" ref="session_switch" id="' + default_value.replace(" ", "_") + '"><strong>' + default_value + '</strong></a></li>';
    // sort the temp_list so that it's in alphabetic order
    var sorted_keys = [];
    for (var key in temp_list) {
        sorted_keys.push(key);
    }
    sorted_keys.sort(function (a, b) { return (temp_list[a] > temp_list[b]) ? 1 : -1; });

    for (var j = 0; j < sorted_keys.length; j++) {
        var key_2 = sorted_keys[j];
        var name = temp_list[key_2];
        result += '<li ref="' + id + '"data-linked="' + (is_linked ? 'yes' : 'no') + '"><a style="color:white" ref="session_switch" id="' + key_2 + '"><strong>' + name + '</strong></a></li>';
    }
    return result;
}

// function returns a dictionary {id:html}
function create_label_for_class(random_id_main, suggestion, supress_link, r_id) {
    var result = {};
    // add colors
    var color = handle_color_creation(suggestion.crn);
    if (!(random_id_main in id_to_crn_dict)) { id_to_crn_dict[random_id_main] = suggestion.crn; }
    // check whether the entry to add is a linked list
    var is_linked = (typeof suggestion.is_l) !== "undefined";
    var html_main = '<div class="dropdown" style="display:inline" ref="' + random_id_main + '"><span class="tag label label-info dropdown-toggle" data-toggle="dropdown" id="' + random_id_main + '" style="background-color:' + color + '">' +
        (suggestion.nn ? suggestion.nn : suggestion.n) + (is_linked ? "" : '<a class="remove fa fa-times">') + '</a></span><ul class="dropdown-menu  session-dropdown" style="background-color:' + color + ';"id="drop-' + random_id_main + '">';

    html_main += create_label_dropdown(suggestion.crn, random_id_main, (suggestion.nn ? suggestion.nn : suggestion.n), false);

    html_main += "</ul></div>";
    result[random_id_main] = html_main;
    if (is_linked || supress_link) { return result; }
    if (suggestion.l && Object.keys(suggestion.l).length > 0) {
        $.each(suggestion.l, function (key, value) {
            var l_color = handle_color_creation(value);
            var tooltip = suggestion.n + " requires " + key;
            var link_random_id = r_id || guidGenerator();
            if (!(link_random_id in id_to_crn_dict)) { id_to_crn_dict[link_random_id] = value; }
            var link_html = '<div class="dropdown" style="display:inline"' + '" ref="' + random_id_main + '"><span style="background-color:' + l_color + '" class="tag label label-info dropdown-toggle" data-toggle="dropdown" data-placement="bottom" title="' + tooltip + '" id="' + link_random_id + '">' + key + '</span><ul class="dropdown-menu session-dropdown" style="background-color:' + l_color + ';"id="drop-' + link_random_id + '">';
            link_html += create_label_dropdown(value, link_random_id, key, true);
            link_html += "</ul></div>";
            result[link_random_id] = link_html;
            if ($(window).width() > 700) {
                $('body').tooltip({
                    selector: "#" + link_random_id,
                    container: 'body'
                });
            }
        });
    }
    return result;
}

function get_search_entry_from_crn(crn) {
    for (var i = 0; i < course_search_table.length; i++) {
        if (course_search_table[i].n === crn) {
            return course_search_table[i];
        }
    }
    return null;
}

function handle_tt_menu(){
   var menu = $(".tt-menu");
   var parent = menu.parent().parent().parent();
   menu.css("width", parent.width());
}

function handle_tooltip(){
    if ($(window).width() >= 700) {
        // enable tooltips
        $('[data-toggle="tooltip"]').tooltip();
    } else{
        $('[data-toggle="tooltip"]').tooltip("destroy");
    }
}


function add_class_entry_to_selected(entry, supress_link, r_id) {
    // if r_id is specified, it will force to use that id for all elements
    var random_id = r_id || guidGenerator();
    suggestion_list[random_id] = entry;
    var result = create_label_for_class(random_id, entry, supress_link, r_id);
    for (var key in result) {
        var html = result[key];
        $(html).appendTo($('#course-selection')).hide().fadeIn(600);
        
        // toggle the drop down
        $("#key").dropdown();
    }
    // add event listener
    $(document).on("click", "[ref=session_switch]", function (e) {
        e.stopPropagation();
        e.preventDefault();
        e.stopImmediatePropagation();
        var text = $(e.target).text();
        var a = $(e.target).parent();
        var li = a.parent();
        var is_linked = li.attr("data-linked") === "yes";
        var crn = $(this).attr("id");
        var ref = $(this).parent().attr("ref");
        if (isNaN(crn)) {
            // original course number
            if (is_linked) {
                delete linked_course_overriden[ref];
            }
            else {
                selected_course[ref] = suggestion_list[ref].crn;
            }
        } else {
            if (is_linked) {
                // add to overridden linked list 
                linked_course_overriden[ref] = [crn];
            }
            else {
                selected_course[ref] = [crn];
            }
        }
        
        // change the label text
        var id = li.attr("ref");
        // need to change the text without removing its child element
        $("#" + id).contents().filter(function(){ return this.nodeType == 3; }).first().replaceWith(text).fadeIn(200);
    });

    // add it to the selected courses if it's not a linked list
    if (typeof (entry.is_l) === "undefined") {
        selected_course[random_id] = entry.crn;
    }
}

function handle_selection(selected_course) {
    $('#search .typeahead').bind('typeahead:select', function (ev, suggestion) {
        add_class_entry_to_selected(suggestion, false);

        // clear the search input
        $('.typeahead').typeahead('val', '');
    });
}

function generate_course_from_name(course_name) {
    var entry, entry2;
    var crn;
	var test_name = Number(course_name);
    if (isNaN(test_name)) {
        // actual course name
        // this way is proven to be faster than $.grep
        for (var key_1 in course_description_table) {
            entry = course_description_table[key_1];
            if (entry.n == course_name) {
                crn = key_1;
                break;
            }
        }
        
        // grab the title and description
        for (var key_2 in course_search_table) {
            entry2 = course_search_table[key_2];
            if (entry2.crn.indexOf(crn) >= 0 && entry2.ti) {
                break;
            }
        }

    } else {
        entry = course_description_table[course_name];
        crn = course_name;
		// grab the title and description
        for (var key_2 in course_search_table) {
            entry2 = course_search_table[key_2];
            if (entry2.crn.indexOf(crn) >= 0 && entry2.ti) {
                break;
            }
        }
    }
    return {"crn" : crn, "html" : "<p><b>Title: </b>" + entry2.ti + "</p>" + "<p><b>Instructor: </b>" + entry.i + "</p>" +
        "<p><b>Description: </b>" + entry2.d + "</p>" + "<p><b>Location: </b>" + (entry.r === "" ? "TBA" : entry.r) + "</p>" +
        "<p><b>CRN: </b>" + crn + "</p>"};
}

function create_tag_desc(desc_table, tags, ccc) {
    var list = tags[ccc];
    var result = "";
    for (var i = 0; i < list.length; i++) {
        var entry = list[i];
        for (var j = 0; j < desc_table.length; j++) {
            var class_entry = desc_table[j];
            if (class_entry.n === entry) {
                result += '<p><b>' + entry + ' </b>' + class_entry.ti + ": " + class_entry.d.split(".")[0] + '.</p>';
            }
        }
    }
    return result;
}

function handle_upload() {
    $("#course-upload-table").empty();
    if (is_local_classes_empty()) {
        $("#upload").hide();
        return;
    }
    var raw_html = "";
    var class_list = get_local_classes();
    for (var name in class_list) {
        var classes = class_list[name];
        raw_html += "<tr><td>" + name + "</td><td>";
        var temp = "";
        for (var j = 0; j < classes.length; j++) {
            temp += course_description_table[classes[j]].n + "; " + (j % 3 == 2 && j != classes.length - 1 ? "<br>" : "");
        }
        raw_html += temp.substring(0, temp.length - 2) + "</td>";
        var id = 'schedule-' + name;
        raw_html += '<td><a><i id="' + id + '" class="fa fa-upload upload-icon"></i></a><a><i style="color:red; position:relative; left:1vw" ref="' +
        id + '"class="fa fa-times upload-delete-icon"></i></a></td></tr>';
    }
    $("#course-upload-table").append(raw_html);
            
    // set up the events
    $(".upload-icon").click(function () {
        // JS scoping problem
        var load_classes = get_local_classes();
        var id = $(this).attr("id");
        var name = id.replace(id.split("-")[0] + "-", "");
        var load_class = load_classes[name];
        var entry_list = [];
        for(var i = 0; i < load_class.length; i++){
            entry_list.push(get_search_entry_from_crn(load_class[i]));
        }
        var class_result = {};
        var has_used = false;
        for (var j = 0; j < entry_list.length; j++) {
            var entry = entry_list[j];
            // add it to the overriden list
            if (entry.is_l) {
                var random_id = guidGenerator();
                linked_course_overriden[random_id] = [load_class[j]];
                // find its parent
                entry.parent = null;
                for(var k = 0; k < entry_list.length; k++){
                    if(is_in_linked_list(entry_list[k].l, load_class[j])){
                        has_used = true;
                        if(Object.keys(class_result).indexOf(k.toString()) >= 0){
                            class_result[k].push(entry);
                        } else {
                            class_result[k] = [entry];
                        }
                    }
                }
            }
            if(!has_used){
                if(Object.keys(class_result).indexOf(j.toString()) < 0){
                    class_result[j] = [];
                }
            }
            // reset the flag
            has_used = false;
            
        }
        for(var key in class_result){
            var r_id = guidGenerator();
            add_class_entry_to_selected(entry_list[key], true, r_id);
            for(var l = 0; l < class_result[key].length; l++){
                add_class_entry_to_selected(class_result[key][l], true, r_id);
            }
        }
        $('#load-modal').modal("hide");
    });

    $(".upload-delete-icon").click(function () {
        // re-consider the implementation.
        // consiering move it to global variable
        var ref = $(this).attr("ref");
        var name = ref.replace(ref.split("-")[0] + "-", "");
        remove_local_class(name);
        $(this).closest("tr").fadeOut(400).remove();
        if (is_local_classes_empty()) {
            $("#upload").hide();
        }
    });
            
    // show the modal
    $('#load-modal').modal("show");
}

String.prototype.capitalize = function() {
   return this.charAt(0).toUpperCase() + this.slice(1);
}

function create_tour() {
    // Instance the tour
    var tour = new Tour({
        steps: [{
            element: "#toggle-tag-search",
            title: "Quick requirement lookup",
            content: "Click here to look up all the requirement-related courses",
            placement: "left"
        }, {
                element: "#search-box",
                title: "Search courses",
                content: "Type the course name or CRN here to add your class to the search list",
                placement: "bottom"
            }, {
                element: "#search-button",
                title: "Schedule",
                content: "Click here to let Ninja schedule your classes for you",
                placement: "bottom"
            }, {
                element: "#toggle-web-tour",
                title: "Web tour",
                content: "Click here to toggle the web tour again.",
                placement: "left"
            }

        ]
    });

    tour.init();

    return tour;
}

function get_save_name(callback) {
    var input_name;
    BootstrapDialog.show({
        title: 'Give it a name so that Ninja can remember it',
        message: 'Please enter the name for your schedule: <input type="text" class="form-control">',
        closable: false,
        data : {canCancel : false},
        onhide: function (dialogRef) {
            var name = dialogRef.getModalBody().find('input').val();
            return dialogRef.getData("canCancel") || (!($.trim(name).length === 0));
        },
        buttons: [{
            label: 'OK',
            action: function (dialogRef) {
                input_name = dialogRef.getModalBody().find('input').val();
                dialogRef.close();
                callback(input_name);
            }
        },
            {
                label: "Cancel",
                action: function (dialogRef) {
                    dialogRef.setData("canCancel", true);
                    dialogRef.close();
                }
            }]
    });
}

function set_current_school_term(term){
    // handle the string
    var is_update = current_term.length === 0? false : true;
    current_term = term;
    $('#term-string').text(term);
    // clean all the results;
    // class_events = [];
    current_class_index = 0;
    schedule_result = [];
    schedule_result_temp = [];  // this is used as a cache to speed up duplication search
    color_dict = {};
    //course_description_table = {};
    //course_search_table = [];
    id_to_crn_dict = {};
    linked_course_overriden = {};
    suggestion_list = {};
    selected_course = {};
    
    // clean the UI
    $("#schedule-row").hide("slow");
    $(".footer").show("slow");   
    $("#course-selection").empty(); 
    // refetch data
    get_data(is_update);

}

function get_data(is_update){
    $.getJSON("/data/" + current_term + "-search.json", function (search_items) {
        course_search_table = search_items;
        $('#tag-search-modal').on('show.bs.modal', function (e) {
            // first time
            var isEmpty = $("#tag-content").html() === "";
            if (isEmpty) {
                $.getJSON("/data/" + current_term + "-tag.json", function (tags) {
                    var sorted_tag_list = Object.keys(tags);
                    sorted_tag_list.sort();
                    for (var i = 0; i < sorted_tag_list.length; i++) {
                        var ccc = sorted_tag_list[i];
                        $("#sidebar").append('<li><a ref=tag-search>' + ccc + '</a></li>');
                    }
                    $("[ref=tag-search]").click(function (e) {
                        var tag = $(e.target).text();
                        var p = create_tag_desc(search_items, tags, tag);
                        $("#tag-content").empty();
                        $(p).appendTo($('#tag-content')).hide().show(500);
                    });
                    var p = create_tag_desc(search_items, tags, ccc);
                    $("#tag-content").empty();
                    $(p).appendTo($('#tag-content')).hide().show(500);

                });
            }
        });

        setup_typeahead(search_items);
        search_list = search_items;
    });

    $.getJSON("/data/" + current_term + "-courses.json", function (data) {
        selected_course = {};

        course_description_table = data;
        if(is_update)
            return;
        handle_selection(selected_course);
        /*$('#search-button').click(function () {
            if (Object.keys(selected_course).length === 0) {
                BootstrapDialog.alert({
                    type: BootstrapDialog.TYPE_WARNING,
                    title: "Warning",
                    message: 'Please select as least one course to schedule.'
                });

            } else {
                schedule(selected_course, course_description_table, search_list);
            }
        });*/

    });

}


$(function () {
    // hide UI item first
    if (!is_local_classes_empty()) {
        $("#upload").show(300);
    }
    
    // download the search_items
    var search_list = [];
    $('#calendar').fullCalendar({
        height: "auto",
        weekends: false, // will hide Saturdays and Sundays
        header: {
            left: "",
            right: ''
        },
        defaultView: "agendaWeek",
        columnFormat: "ddd",
        defaultDate: moment().startOf('isoweek'), // just start from Monday
        allDaySlot: false,
        minTime: "8:00:00",
        maxTime: "22:00:00",
        displayEventTime: false,
        windowResize: function (view) {
            if ($(window).width() < 300) {
                $('#calendar').fullCalendar('changeView', 'basicWeek');

            } else {
                $('#calendar').fullCalendar('changeView', 'agendaWeek');
            }
        },
        eventClick: function (calEvent, jsEvent, view) {
            var course_name = calEvent.title;
            var course = generate_course_from_name(calEvent.title);
            var dialog = new BootstrapDialog({
                title: course_name,
                message: course.html
            });
            dialog.realize();
            dialog.getModalHeader().css("background-color", color_dict[course.crn]);
            dialog.open();
        },
        eventMouseover: function (event, jsEvent, view) {
            $(this).css("background-color", color_dict[event.crn]);
        },
        eventMouseout: function (event, jsEvent, view) {
            $(this).css("background-color", "white");
        }
    });
    $('#calendar').fullCalendar('addEventSource', class_events);


    $(document).on("click", ".remove", function (e) {
        var parent = $(e.target).parent();
        var ref = parent.attr("id");
        // remove the html element
        $("[ref=" + ref + "]").hide().remove();

        // remove it from the selected courses
        delete selected_course[ref];
    });

    // get the default data
    $.getJSON("/data/config.json", function (data) {
        set_current_school_term(data[0].name + "/" +  data[0].term[0]);
        for(var i = 0; i < data.length; i++){
            // build the choose section
            var entry = data[i];
            $("#term-dropdown").append('<li class="dropdown-header">' + entry.name.capitalize() + '</li>');
            for(var j = 0; j < entry.term.length; j++){
                $("#term-dropdown").append('<li ref="term-choice"><a href="#">' + entry.name + "/" + entry.term[j] + '</a></li>');
            }
        }
        // get_data();
    });

    $("#show-left").click(function () {
        set_current_class_index(current_class_index - 1);
    });

    $("#show-right").click(function () {
        set_current_class_index(current_class_index + 1);
    });

    $("#download").click(function () {
        var classes = schedule_result[current_class_index];
        var url = "download.html?";
        for (var i = 0; i < classes.length; i++) {
            var key = classes[i].crn;
            url += key + "=" + key + "&"
        }

        url = url.substring(0, url.length - 1);
        $('#download-modal').on('show.bs.modal', function () {
            $('#download-iframe').attr("src", url);

        });
        $('#download-modal').modal('show');
    });

    $("#toggle-tag-search").click(function () {
        $("#tag-search-modal").modal('toggle');
    });

    $("#toggle-change-term").popover({ 
        html : true,
        title: '<span class="text-info"><strong>Choose the semester &nbsp; </strong></span>' +
               '<button type="button" id="close" class="close"'+
               'onclick="$(&quot;#toggle-change-term&quot;).popover(&quot;hide&quot;);">&times;</button>',
        content: function() {
            return $("#choose-term-popover").html();
            },
        trigger: "click"
    });

    $("#jump-schedule").click(function () {
        set_current_class_index(parseInt($("#jump-value").val(), 10));
        $('#paging').popover('hide');
    });

    $("#paging").popover({
        html: true,
        title: function () {
            return "Choose a schedule to display";
        },
        content: function () {
            return $("#jump-content").html();
        },
        placement: "bottom"
    });
    // fix for https://github.com/twbs/bootstrap/issues/16732
    $('body').on('hidden.bs.popover', function (e) {
        $(e.target).data("bs.popover").inState.click = false;
    });

    $(document).on("click", "#jump-schedule", function (e) {
        if (!isNaN($("#jump-value").val())) {
            var val = parseInt($("#jump-value").val(), 10);
            var max_val = parseInt($("#jump-value").attr("data-max"), 10);
            if (val <= max_val && val > 0) {
                set_current_class_index(val - 1);
            }
        }
        $("#paging").popover("hide");
    });

    $(document).on("click", "#cancel-jump-schedule", function (e) {
        $("#paging").popover("hide");
    });

    var tour = create_tour();
    $("#toggle-web-tour").click(function () {
        tour.start(true);
    });


    $("#upload").click(function () {
        handle_upload();
    });

    $("#save-schedule").click(function () {
        get_save_name(function (name) {
            var classes = schedule_result[current_class_index];
            var class_list = [];
            for (var i = 0; i < classes.length; i++) {
                class_list.push(classes[i].crn);
            }
            add_local_classes(name, class_list);
            $("#upload").fadeIn(300);
        });
    });
    
    $(document).on("click", "[ref=term-choice]", function(e){
         set_current_school_term($(e.target).text());
    });
    
    $( window ).resize(function() {
        handle_tt_menu();
        handle_tooltip();
    });
    
    handle_tooltip();

    $('#search-button').click(function () {
        if (Object.keys(selected_course).length === 0) {
            BootstrapDialog.alert({
                type: BootstrapDialog.TYPE_WARNING,
                title: "Warning",
                message: 'Please select as least one course to schedule.'
            });

        } else {
            schedule(selected_course, course_description_table, search_list);
        }
    });
});
